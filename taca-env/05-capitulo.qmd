title: "Propiedades y Operaciones de Lenguajes Regulares"
author: "Marylin Alvarado"
format: html
toc: true
---

## 5. Propiedades y Operaciones de Lenguajes Regulares

Aquí se analizan las características inherentes de la familia de lenguajes regulares, demostrando cómo se pueden combinar y optimizar.
***

### 5.1 Propiedades de Clausura de Lenguajes Regulares

Las **propiedades de clausura** de los lenguajes regulares establecen que si tomamos uno o más lenguajes regulares y aplicamos una operación específica (como unión, concatenación o intersección), el lenguaje resultante también será un lenguaje regular. Los Autómatas Finitos Deterministas (**AFD**) son fundamentales para demostrar estas propiedades mediante la construcción de nuevos autómatas.

#### Concepto de Clausura con AFDs

La demostración de la clausura se realiza construyendo un nuevo AFD, $A_{nuevo}$, a partir de los AFDs originales, $A_1$ y $A_2$, de tal manera que $L(A_{nuevo})$ sea el resultado de la operación aplicada a $L(A_1)$ y $L(A_2)$. Esta construcción se conoce comúnmente como la **Construcción Producto**.

#### Unión ($\cup$)

* **Operación:** $L(A_1) \cup L(A_2)$
* **Demostración con AFDs (Construcción Producto):**
    * Se construye un nuevo AFD cuyos estados son **pares ordenados** $(q_1, q_2)$, donde $q_1$ es un estado de $A_1$ y $q_2$ es un estado de $A_2$.
    * Un estado $(q_1, q_2)$ es un **estado final** en el nuevo AFD si al menos uno de los estados originales es final, es decir, si $q_1 \in F_1$ **o** $q_2 \in F_2$.
* **Conclusión:** Los lenguajes regulares son cerrados bajo la **unión**.

#### Concatenación ($\cdot$)

* **Operación:** $L(A_1) \cdot L(A_2)$
* **Demostración con AFDs:** Aunque se puede demostrar con AFDs, es más complejo que en AFNDs. En la práctica, se utiliza el hecho de que los AFNDs son equivalentes a los AFDs. La demostración mediante AFNDs ($\epsilon$-transiciones) es más sencilla y directa.
* **Conclusión:** Los lenguajes regulares son cerrados bajo la **concatenación**.

#### Intersección ($\cap$)

* **Operación:** $L(A_1) \cap L(A_2)$
* **Demostración con AFDs (Construcción Producto):** Se utiliza la misma **construcción producto** de estados $(q_1, q_2)$.
    * Un estado $(q_1, q_2)$ es un **estado final** en el nuevo AFD si **ambos** estados originales son finales, es decir, si $q_1 \in F_1$ **y** $q_2 \in F_2$.
* **Conclusión:** Los lenguajes regulares son cerrados bajo la **intersección**.

***

### 5.2 Operaciones de Clausura en NFAs

La demostración de las propiedades de clausura para los lenguajes regulares (Unión, Concatenación y Clausura de Kleene) es más sencilla y elegante utilizando **Autómatas Finitos No Deterministas (AFND)**, especialmente con el uso de las $\epsilon$-transiciones. La flexibilidad del no-determinismo permite "unir" los autómatas de manera eficiente sin explosionar el número de estados de forma inmediata.

#### Clausura de Kleene (Estrella) ($\star$)

* **Definición:** $L^{\star} = L^0 \cup L^1 \cup L^2 \cup \dots$
* **Demostración con AFNDs:**
    1.  Se añade un **nuevo estado inicial/final** $q_{nuevo}$.
    2.  Se añade una **$\epsilon$-transición** desde $q_{nuevo}$ al antiguo estado inicial de $A$ (para comenzar la primera iteración o la única).
    3.  Se añaden **$\epsilon$-transiciones** desde cada estado final de $A$ de vuelta a $q_{nuevo}$ (o al antiguo estado inicial de $A$) para permitir la repetición (la estrella).
    4.  El estado $q_{nuevo}$ acepta $\epsilon$ (la cadena vacía), que es parte de $L^0$.
* **Ventaja sobre AFDs:** Un AFD requeriría un mecanismo mucho más complejo (y a menudo más grande) para manejar los puntos de repetición y la posible vuelta al estado inicial después de cada aceptación.

#### Concatenación ($\cdot$)

* **Definición:** $L(A_1) \cdot L(A_2)$
* **Demostración con AFNDs:**
    1.  Se mantiene el estado inicial de $A_1$ como el nuevo estado inicial.
    2.  Se añaden **$\epsilon$-transiciones** desde todos los estados finales de $A_1$ hacia el estado inicial de $A_2$.
    3.  Los estados finales de $A_1$ dejan de ser finales.
    4.  Los estados finales de $A_2$ se convierten en los nuevos estados finales.
* **Ventaja sobre AFDs:** El AFND simplemente "conecta" el final del primer autómata con el inicio del segundo sin la necesidad de construir un producto que simule todas las combinaciones posibles de estados intermedios.

***

### 5.3 Algoritmos de Minimización de AFDs

La minimización de un AFD busca encontrar el **AFD mínimo**, que es un AFD equivalente al original, pero con el menor número posible de estados.

#### Concepto de Estados Equivalentes e Indistinguibles

La minimización se fundamenta en la capacidad de identificar y fusionar estados que tienen el mismo comportamiento de aceptación:

* **Estados Indistinguibles (Equivalentes):** Dos estados $p$ y $q$ de un AFD, $A$, son **indistinguibles** si, para *cualquier* palabra $w$ que se les suministre, o bien ambos terminan en un estado final, o bien ambos terminan en un estado no final. En otras palabras, aceptan exactamente el mismo conjunto de sufijos: $L_A(p) = L_A(q)$.
* **Estados Distinguibles:** Dos estados $p$ y $q$ son **distinguibles** si existe al menos una palabra $w$ (la **cadena distinguible**) tal que la lectura de $w$ desde $p$ conduce a un estado final y la lectura de $w$ desde $q$ conduce a un estado no final, o viceversa.

#### Algoritmo de Llenado de Tabla (*Table-Filling Algorithm*)

Este es un enfoque sistemático para encontrar todos los pares de estados distinguibles:

1.  **Paso Base:** Marcar como distinguibles todos los pares $(p, q)$ donde $p$ es final y $q$ no es final (porque $\epsilon$ es una cadena distinguible).
2.  **Paso Inductivo:** Iterar. Un par $(p, q)$ se marca como distinguible si, para algún símbolo de entrada $a$, el par de estados de destino $(\delta(p, a), \delta(q, a))$ ya ha sido previamente marcado como distinguible.
3.  **Resultado:** Cuando no se pueden hacer más marcas, los pares de estados que quedan sin marcar son los indistinguibles y deben fusionarse en un único estado en el AFD mínimo.

#### Algoritmo de Hopcroft

Este algoritmo es un método de partición que es más eficiente para grandes autómatas, con una complejidad de tiempo de $O(n \log n)$.

1.  **Inicialización:** Se crea una partición inicial $P$ de los estados en dos grupos: $F$ (estados finales) y $Q - F$ (estados no finales).
2.  **Refinamiento:** Iterar hasta que la partición $P$ no cambie. En cada paso, se refina la partición tomando un bloque $B$ de $P$ y un símbolo $a$, y se divide $B$ en sub-bloques basados en el bloque al que se llega con $a$. Si los estados en $B$ tienen transiciones con $a$ que llegan a diferentes bloques de la partición actual, entonces $B$ debe ser dividido.
3.  **Resultado:** Los bloques de la partición final representan los estados del AFD mínimo. Se construye el autómata mínimo (el autómata cociente) tomando estos bloques como sus estados.

Ambos algoritmos conducen al mismo **AFD Mínimo Único** (salvo por el nombre de los estados).
```
