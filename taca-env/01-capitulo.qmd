---
title: "Capitulo 1"
format:
        html: default
        pdf: default
toc: true
bibliography: references.bib
nocite: "@*"
---

# 1.1 Definici√≥n formal de un DFA (Aut√≥mata Finito Determinista)

Un DFA se define formalmente como una 5‚Äìtupla:

\[
M = (Q, Œ£, Œ¥, q_0, F)
\]

donde:

* **\(Q\)** ‚Üí *Conjunto de estados:* Es un conjunto finito de estados.  
  **Ejemplo:** \(Q = \{q_0, q_1\}\)

* **\(\Œ£\)** ‚Üí *Alfabeto:* Conjunto de s√≠mbolos permitidos.  
  **Ejemplo:** \(\Œ£ = \{0, 1\}\)

* **\(\Œ¥\)** ‚Üí *Funci√≥n de transici√≥n:* Indica a qu√© estado se va dependiendo del estado actual.  
  \[
  \delta: Q \times \Sigma \rightarrow Q
  \]  
  **Ejemplo:** \(\Œ¥(q_0, 1) = q_1\)

* **\(q_0\)** ‚Üí *Estado inicial:* El estado donde empieza la m√°quina.  
  **Ejemplo:** \(q_0 = q_0\)

* **\(F\)** ‚Üí *Conjunto de estados de aceptaci√≥n:* Los estados finales o aceptadores.  
  **Ejemplo:** \(F = \{q_0\}\)

---

### Ejemplo: DFA para ‚Äúcadenas con n√∫mero par de 1‚Äôs‚Äù

El lenguaje consiste en aceptar todas las cadenas de 0‚Äôs y 1‚Äôs donde la cantidad de unos sea par.

Ejemplos aceptados:

‚úî \( \varepsilon \) (cadena vac√≠a) ‚Üí 0 unos ‚Üí par  
‚úî 0, 00, 010, 1010  

Ejemplos rechazados:

‚úò 1, 01, 001, 111 ‚Üí n√∫mero impar de unos

---

# 1.2 Idea del dise√±o

Solo necesitamos saber si la cantidad de 1‚Äôs vista hasta ahora es **par** o **impar**, por lo que basta con dos estados:

* **\(q_0\)** ‚Üí hemos visto un n√∫mero **par** de 1‚Äôs  
* **\(q_1\)** ‚Üí hemos visto un n√∫mero **impar** de 1‚Äôs

Reglas clave:

* Al leer un **1**, el DFA **cambia de estado** (alterna entre par e impar).  
* Al leer un **0**, el DFA **permanece en el mismo estado**, ya que no afecta la paridad.


## 1.3.1 Aut√≥matas Finitos Deterministas (DFAs)

### 1. Concepto Intuitivo y Operaci√≥n

Un aut√≥mata finito determinista (DFA) puede imaginarse como una m√°quina muy simple que procesa una palabra **s√≠mbolo por s√≠mbolo**, siguiendo reglas estrictas.

- **Inicio:** El aut√≥mata comienza en un estado inicial y el cabezal de lectura se coloca en la primera letra de la palabra.
- **Paso a paso:** Cada vez que lee una letra, usa su *funci√≥n de transici√≥n* para decidir a qu√© estado debe pasar.  
  Esta decisi√≥n depende **solo** del estado en el que se encuentra y de la letra le√≠da.
- **Aceptaci√≥n:** Una palabra es aceptada si, al terminar de leerla, el aut√≥mata termina en un estado que pertenece al conjunto de *estados finales*.

En pocas palabras:  
**Un DFA recorre la palabra letra por letra y cambia de estado seg√∫n reglas fijas. Si termina en un estado final, acepta; si no, la rechaza.**

---

### 2. Componentes y Transiciones

La secci√≥n describe las ideas clave del funcionamiento determinista:

- **Determinismo:**  
  Para cada combinaci√≥n `(estado, s√≠mbolo)`, existe **una √∫nica** transici√≥n posible.  
  No hay ambig√ºedad ni elecci√≥n entre varias rutas.

- **Carreras (runs):**  
  Es la secuencia de estados por los que pasa el aut√≥mata al leer la palabra completa.  
  Ejemplo:  
  \[
  q_0 \xrightarrow{a} q_1 \xrightarrow{b} q_3 \xrightarrow{b} q_2
  \]

- **Aceptaci√≥n/Rechazo:**  
  Una palabra es **aceptada** si la carrera termina en un estado final.  
  Caso contrario, es rechazada.

---

### 3. Ejemplo de la Secci√≥n 1.3.1

La secci√≥n incluye un DFA concreto:

- **Ejemplo 1.8:**  
  Se muestra el aut√≥mata:  
  \[
  A = (Q, \Sigma, \delta, q_0, F)
  \]
  donde:
  - \( Q = \{ q_0, q_1, q_2, q_3 \} \)
  - \( \Sigma = \{ a, b \} \)
  - \( F = \{ q_0 \} \) (el √∫nico estado de aceptaci√≥n)

- **Carrera de ejemplo sobre la palabra `aabb`:**

  \[
  q_0 \xrightarrow{a} q_1 \xrightarrow{a} q_0 \xrightarrow{b} q_3 \xrightarrow{b} q_0
  \]

  Aqu√≠, la palabra **s√≠ se acepta**, porque termina en \( q_0 \), que es estado final.

- **Estado trampa:**  
  Tambi√©n se menciona un DFA con un estado trampa, que es un estado del que no se puede salir.  
  Una vez que entras all√≠, la palabra queda autom√°ticamente rechazada.  
  Aunque existe, a veces no se dibuja en los diagramas por simplicidad.

## 1.3.2 DFAs como estructuras de datos

Los **Aut√≥matas Finitos Deterministas (DFAs)** son modelos matem√°ticos utilizados para representar sistemas capaces de reconocer patrones en cadenas de s√≠mbolos. Aunque provienen de la teor√≠a de lenguajes formales, tambi√©n se consideran **estructuras de datos**, ya que almacenan informaci√≥n de forma organizada para procesar entradas paso a paso siguiendo reglas definidas.

Desde una perspectiva computacional, un DFA es una **estructura compuesta por elementos finitos y relaciones internas**, dise√±ada para describir comportamientos secuenciales.

---

## Componentes fundamentales de un DFA

### ‚úî 1. Estados  
Un DFA contiene un conjunto finito de **estados**, cada uno representando una situaci√≥n del sistema.  
Como estructura de datos, los estados funcionan como **nodos etiquetados** que permiten recordar:

- qu√© s√≠mbolos se han procesado,
- en qu√© condici√≥n se encuentra la m√°quina.

---

### ‚úî 2. Alfabeto  
El alfabeto es el conjunto finito de s√≠mbolos v√°lidos como entrada.  
Act√∫a como un dominio de valores permitido, limitando la complejidad del procesamiento.

---

### ‚úî 3. Estado inicial  
Es el punto de partida de la m√°quina.  
Desde la perspectiva de estructura de datos, equivale a un **nodo ra√≠z** o a una variable inicializada.

---

### ‚úî 4. Estados de aceptaci√≥n  
Son estados marcados como "v√°lidos".  
Determinan si la cadena procesada es **aceptada** o **rechazada** al finalizar.

---

### ‚úî 5. Funci√≥n de transici√≥n  
La funci√≥n de transici√≥n especifica:

> ‚ÄúSi estoy en el estado X y leo el s√≠mbolo Y, voy al estado Z‚Äù.

Como estructura de datos puede representarse mediante:

- tablas,
- grafos dirigidos,
- diccionarios (clave ‚Üí valor),
- listas de adyacencia.

Es el mecanismo que almacena las reglas de movimiento.


# 1.3.2.1 Por qu√© un DFA es una estructura de datos

### üîπ 1. Almacenamiento organizado  
Un DFA guarda:

- estados,
- s√≠mbolos,
- transiciones,
- estados finales.

Todo su dise√±o es estructural: define c√≥mo se organiza y consulta la informaci√≥n.


### üîπ 2. Operaciones definidas  
La operaci√≥n principal del DFA es:

> Procesar una cadena s√≠mbolo por s√≠mbolo.

Equivale a recorrer:

- un grafo,
- una tabla,
- un mapa de transiciones.


### üîπ 3. Acceso eficiente  
Cada transici√≥n se ejecuta en **O(1)**:  
para cada par *(estado, s√≠mbolo)* hay un √∫nico destino.

Esto los hace ideales para:

- analizadores l√©xicos,
- validadores,
- reconocimiento r√°pido de patrones.


### üîπ 4. M√∫ltiples representaciones internas  
Un DFA puede almacenarse como:

- matriz de transici√≥n,
- tabla hash,
- lista de adyacencia,
- json/yaml,
- clases de programaci√≥n (Java, Python, etc.).

Esto evidencia que tambi√©n es una **estructura de datos**.


# 1.3.2.2 Interpretaci√≥n computacional

Desde el punto de vista computacional, un DFA es una **m√°quina que interpreta datos** mediante una estructura fija.

La m√°quina:

1. Recibe s√≠mbolos.
2. Recorre su estructura interna (estados y transiciones).
3. Mantiene solo una memoria finita (el estado actual).
4. Produce una salida binaria: *Aceptar* o *Rechazar*.
