---
title: "Capitulo 1"
format:
        html: default
        pdf: default
toc: true
bibliography: references.bib
nocite: "@*"
---

# 1.1 Definici√≥n formal de un DFA (Aut√≥mata Finito Determinista)

Un DFA se define formalmente como una 5‚Äìtupla:

\[
M = (Q, Œ£, Œ¥, q_0, F)
\]

donde:

* **\(Q\)** ‚Üí *Conjunto de estados:* Es un conjunto finito de estados.  
  **Ejemplo:** \(Q = \{q_0, q_1\}\)

* **\(\Œ£\)** ‚Üí *Alfabeto:* Conjunto de s√≠mbolos permitidos.  
  **Ejemplo:** \(\Œ£ = \{0, 1\}\)

* **\(\Œ¥\)** ‚Üí *Funci√≥n de transici√≥n:* Indica a qu√© estado se va dependiendo del estado actual.  
  \[
  \delta: Q \times \Sigma \rightarrow Q
  \]  
  **Ejemplo:** \(\Œ¥(q_0, 1) = q_1\)

* **\(q_0\)** ‚Üí *Estado inicial:* El estado donde empieza la m√°quina.  
  **Ejemplo:** \(q_0 = q_0\)

* **\(F\)** ‚Üí *Conjunto de estados de aceptaci√≥n:* Los estados finales o aceptadores.  
  **Ejemplo:** \(F = \{q_0\}\)

---

### Ejemplo: DFA para ‚Äúcadenas con n√∫mero par de 1‚Äôs‚Äù

El lenguaje consiste en aceptar todas las cadenas de 0‚Äôs y 1‚Äôs donde la cantidad de unos sea par.

Ejemplos aceptados:

‚úî \( \varepsilon \) (cadena vac√≠a) ‚Üí 0 unos ‚Üí par  
‚úî 0, 00, 010, 1010  

Ejemplos rechazados:

‚úò 1, 01, 001, 111 ‚Üí n√∫mero impar de unos

---

# 1.2 Idea del dise√±o

Solo necesitamos saber si la cantidad de 1‚Äôs vista hasta ahora es **par** o **impar**, por lo que basta con dos estados:

* **\(q_0\)** ‚Üí hemos visto un n√∫mero **par** de 1‚Äôs  
* **\(q_1\)** ‚Üí hemos visto un n√∫mero **impar** de 1‚Äôs

Reglas clave:

* Al leer un **1**, el DFA **cambia de estado** (alterna entre par e impar).  
* Al leer un **0**, el DFA **permanece en el mismo estado**, ya que no afecta la paridad.


## 1.3.1 Aut√≥matas Finitos Deterministas (DFAs)

### 1. Concepto Intuitivo y Operaci√≥n

Un aut√≥mata finito determinista (DFA) puede imaginarse como una m√°quina muy simple que procesa una palabra **s√≠mbolo por s√≠mbolo**, siguiendo reglas estrictas.

- **Inicio:** El aut√≥mata comienza en un estado inicial y el cabezal de lectura se coloca en la primera letra de la palabra.
- **Paso a paso:** Cada vez que lee una letra, usa su *funci√≥n de transici√≥n* para decidir a qu√© estado debe pasar.  
  Esta decisi√≥n depende **solo** del estado en el que se encuentra y de la letra le√≠da.
- **Aceptaci√≥n:** Una palabra es aceptada si, al terminar de leerla, el aut√≥mata termina en un estado que pertenece al conjunto de *estados finales*.

En pocas palabras:  
**Un DFA recorre la palabra letra por letra y cambia de estado seg√∫n reglas fijas. Si termina en un estado final, acepta; si no, la rechaza.**

---

### 2. Componentes y Transiciones

La secci√≥n describe las ideas clave del funcionamiento determinista:

- **Determinismo:**  
  Para cada combinaci√≥n `(estado, s√≠mbolo)`, existe **una √∫nica** transici√≥n posible.  
  No hay ambig√ºedad ni elecci√≥n entre varias rutas.

- **Carreras (runs):**  
  Es la secuencia de estados por los que pasa el aut√≥mata al leer la palabra completa.  
  Ejemplo:  
  \[
  q_0 \xrightarrow{a} q_1 \xrightarrow{b} q_3 \xrightarrow{b} q_2
  \]

- **Aceptaci√≥n/Rechazo:**  
  Una palabra es **aceptada** si la carrera termina en un estado final.  
  Caso contrario, es rechazada.

---

### 3. Ejemplo de la Secci√≥n 1.3.1

La secci√≥n incluye un DFA concreto:

- **Ejemplo 1.8:**  
  Se muestra el aut√≥mata:  
  \[
  A = (Q, \Sigma, \delta, q_0, F)
  \]
  donde:
  - \( Q = \{ q_0, q_1, q_2, q_3 \} \)
  - \( \Sigma = \{ a, b \} \)
  - \( F = \{ q_0 \} \) (el √∫nico estado de aceptaci√≥n)

- **Carrera de ejemplo sobre la palabra `aabb`:**

  \[
  q_0 \xrightarrow{a} q_1 \xrightarrow{a} q_0 \xrightarrow{b} q_3 \xrightarrow{b} q_0
  \]

  Aqu√≠, la palabra **s√≠ se acepta**, porque termina en \( q_0 \), que es estado final.

- **Estado trampa:**  
  Tambi√©n se menciona un DFA con un estado trampa, que es un estado del que no se puede salir.  
  Una vez que entras all√≠, la palabra queda autom√°ticamente rechazada.  
  Aunque existe, a veces no se dibuja en los diagramas por simplicidad.

## 1.3.2 DFAs como estructuras de datos

Los **Aut√≥matas Finitos Deterministas (DFAs)** son modelos matem√°ticos utilizados para representar sistemas capaces de reconocer patrones en cadenas de s√≠mbolos. Aunque provienen de la teor√≠a de lenguajes formales, tambi√©n se consideran **estructuras de datos**, ya que almacenan informaci√≥n de forma organizada para procesar entradas paso a paso siguiendo reglas definidas.

Desde una perspectiva computacional, un DFA es una **estructura compuesta por elementos finitos y relaciones internas**, dise√±ada para describir comportamientos secuenciales.

---

## Componentes fundamentales de un DFA

### ‚úî 1. Estados  
Un DFA contiene un conjunto finito de **estados**, cada uno representando una situaci√≥n del sistema.  
Como estructura de datos, los estados funcionan como **nodos etiquetados** que permiten recordar:

- qu√© s√≠mbolos se han procesado,
- en qu√© condici√≥n se encuentra la m√°quina.

---

### ‚úî 2. Alfabeto  
El alfabeto es el conjunto finito de s√≠mbolos v√°lidos como entrada.  
Act√∫a como un dominio de valores permitido, limitando la complejidad del procesamiento.

---

### ‚úî 3. Estado inicial  
Es el punto de partida de la m√°quina.  
Desde la perspectiva de estructura de datos, equivale a un **nodo ra√≠z** o a una variable inicializada.

---

### ‚úî 4. Estados de aceptaci√≥n  
Son estados marcados como "v√°lidos".  
Determinan si la cadena procesada es **aceptada** o **rechazada** al finalizar.

---

### ‚úî 5. Funci√≥n de transici√≥n  
La funci√≥n de transici√≥n especifica:

> ‚ÄúSi estoy en el estado X y leo el s√≠mbolo Y, voy al estado Z‚Äù.

Como estructura de datos puede representarse mediante:

- tablas,
- grafos dirigidos,
- diccionarios (clave ‚Üí valor),
- listas de adyacencia.

Es el mecanismo que almacena las reglas de movimiento.


# 1.3.2.1 Por qu√© un DFA es una estructura de datos

### üîπ 1. Almacenamiento organizado  
Un DFA guarda:

- estados,
- s√≠mbolos,
- transiciones,
- estados finales.

Todo su dise√±o es estructural: define c√≥mo se organiza y consulta la informaci√≥n.


### üîπ 2. Operaciones definidas  
La operaci√≥n principal del DFA es:

> Procesar una cadena s√≠mbolo por s√≠mbolo.

Equivale a recorrer:

- un grafo,
- una tabla,
- un mapa de transiciones.


### üîπ 3. Acceso eficiente  
Cada transici√≥n se ejecuta en **O(1)**:  
para cada par *(estado, s√≠mbolo)* hay un √∫nico destino.

Esto los hace ideales para:

- analizadores l√©xicos,
- validadores,
- reconocimiento r√°pido de patrones.


### üîπ 4. M√∫ltiples representaciones internas  
Un DFA puede almacenarse como:

- matriz de transici√≥n,
- tabla hash,
- lista de adyacencia,
- json/yaml,
- clases de programaci√≥n (Java, Python, etc.).

Esto evidencia que tambi√©n es una **estructura de datos**.


# 1.3.2.2 Interpretaci√≥n computacional

Desde el punto de vista computacional, un DFA es una **m√°quina que interpreta datos** mediante una estructura fija.

La m√°quina:

1. Recibe s√≠mbolos.
2. Recorre su estructura interna (estados y transiciones).
3. Mantiene solo una memoria finita (el estado actual).
4. Produce una salida binaria: *Aceptar* o *Rechazar*.


## 1.3.3 Aut√≥matas Finitos No Deterministas (AFND)

Hasta ahora hemos trabajado con Aut√≥matas Finitos Deterministas (AFD), donde las reglas son estrictas: para cada estado y cada s√≠mbolo existe un √∫nico camino a seguir. Sin embargo, los lenguajes m√°s complejos suelen requerir mayor flexibilidad. Aqu√≠ es donde aparece el no determinismo.

Los Aut√≥matas Finitos No Deterministas (AFND), tambi√©n conocidos simplemente como aut√≥matas no deterministas, introducen la posibilidad de elecci√≥n en el procesamiento de palabras. Esto simplifica notablemente la construcci√≥n de aut√≥matas para ciertos lenguajes.

#### Definici√≥n

Imagina que est√°s jugando ajedrez. Un AFD ser√≠a como un juego donde, ante cada posici√≥n del tablero, solo existe un movimiento legal posible: no hay elecci√≥n. En cambio, un Aut√≥mata Finito No Determinista (AFND) funciona como el ajedrez real: ante una misma situaci√≥n puedes tener m√∫ltiples movimientos posibles, o incluso ninguno.

Un AFND es un aut√≥mata finito que, al leer un s√≠mbolo de entrada, puede elegir el siguiente estado de entre un conjunto de estados candidatos.

Formalmente, un AFND es una tupla\
$A = (Q, \Sigma, \delta, Q_0, F)$, donde:

-   $Q$, $\Sigma$ y $F$ (estados, alfabeto y estados finales) son los mismos que en un AFD.
-   $Q_0$ es un conjunto no vac√≠o de estados iniciales (a diferencia del AFD, que tiene solo uno).
-   $\delta : Q \times \Sigma \to \mathcal{P}(Q)$ es la relaci√≥n de transici√≥n, que devuelve un conjunto de posibles estados siguientes.

### Ventajas sobre el AFD

El dise√±o de un AFND suele ser m√°s directo e intuitivo que el de un AFD. En un AFND no estamos obligados a definir qu√© ocurre con cada s√≠mbolo en cada estado. Si un camino no lleva a ninguna parte, simplemente "muere" sin afectar a los dem√°s recorridos. Esto nos permite modelar patrones sin preocuparnos por todas las combinaciones de errores que un AFD obligar√≠a a representar.

#### Diferencias clave con un AFD

La diferencia principal radica en el concepto de recorrido:

| Caracter√≠stica | AFD (Determinista) | AFND (No Determinista) |
|------------------------|------------------------|------------------------|
| Siguiente estado | Totalmente determinado por el estado actual y el s√≠mbolo le√≠do. | Puede elegir entre varios estados posibles. |
| Recorridos por palabra | Exactamente uno. | Puede haber cero, uno o muchos. |
| Estado inicial | Uno solo ($q_0$). | Conjunto no vac√≠o de estados iniciales ($Q_0$). |

#### C√≥mo funcionan las transiciones no deterministas

Para entenderlo, comparemos ambos modelos:

-   En un AFD, si estamos en el estado $q$ y leemos el s√≠mbolo $a$, el siguiente estado $q'$ es √∫nico:\
    $q' = \delta(q, a)$.
-   En un AFND, al estar en $q$ y leer $a$, la funci√≥n $\delta(q, a)$ devuelve un conjunto de estados posibles.\
    El aut√≥mata puede moverse a cualquiera de ellos.\
    Si $\delta(q, a) = \emptyset$, no existe un camino a seguir desde $q$ con la entrada $a$.

Un recorrido (run) de un AFND sobre una entrada $a_0 a_1 \cdots a_n$ es una secuencia\
$p_0, p_1, \ldots, p_n$ tal que:

-   $p_0 \in Q_0$
-   $p_{i+1} \in \delta(p_i, a_i)$

#### Ventajas y usos

Los AFND no aumentan el poder expresivo respecto a los AFD (reconocen los mismos lenguajes regulares), pero ofrecen ventajas importantes:

-   **Facilidad de dise√±o:** construir un AFND suele ser m√°s sencillo.
-   **Representaci√≥n natural de operaciones:** la uni√≥n de lenguajes se representa f√°cilmente mediante bifurcaci√≥n en un AFND.
-   **Aplicaciones algor√≠tmicas:** son la base para algoritmos de b√∫squeda de patrones, donde se construye un AFND a partir de una expresi√≥n regular.

#### Lenguaje reconocido

La aceptaci√≥n en un AFND es **existencial**:

Una palabra $w$ es aceptada si **al menos uno** de los posibles recorridos termina en un estado final.\
Es decir, existe un recorrido $p_0, p_1, \ldots, p_n$ tal que $p_n \in F$.

Si hay varios estados iniciales, el lenguaje reconocido es la **uni√≥n** de los lenguajes aceptados desde cada estado inicial.

En resumen: $$
L(A) = \{\, w \in \Sigma^* : w \text{ es aceptada por } A \,\}.
$$

------------------------------------------------------------------------

## 1.3.4 Aut√≥matas Finitos No Deterministas con $\epsilon$-Transiciones ($\epsilon$-AFND)

Si el AFND nos dio libertad para elegir caminos, el $\epsilon$-AFND a√±ade un ‚Äúsuperpoder‚Äù: la capacidad de moverse sin consumir ning√∫n s√≠mbolo de entrada.

Un AFND con $\epsilon$-transiciones es un aut√≥mata que permite movimientos espont√°neos, sin leer letras del alfabeto.

#### ¬øQu√© son las transiciones √©psilon?

Las $\epsilon$-transiciones son movimientos internos que el aut√≥mata puede realizar sin consumir un s√≠mbolo. Estas transiciones est√°n etiquetadas con la palabra vac√≠a $\epsilon$.

#### C√≥mo funcionan y por qu√© son importantes

Un AFND est√°ndar solo puede cambiar de estado al leer una letra del alfabeto. Un $\epsilon$-AFND puede cambiar de estado al leer una letra o al ejecutar una $\epsilon$-transici√≥n.

Un AFND solo puede cambiar de estado al leer un s√≠mbolo del alfabeto.\
Un $\epsilon$-AFND puede cambiar de estado:

-   al leer un s√≠mbolo, o ejecutando una transici√≥n $\epsilon$.

La relaci√≥n de transici√≥n se extiende: $$
\delta : Q \times (\Sigma \cup \{\epsilon\}) \to \mathcal{P}(Q).
$$

Una palabra $a_1 a_2 \cdots a_n$ es aceptada si existe un recorrido que consume exactamente esa palabra, permitiendo cualquier n√∫mero de transiciones $\epsilon$ antes, entre o despu√©s de los s√≠mbolos.

Estas transiciones son esenciales en algoritmos de conversi√≥n, por ejemplo, al traducir expresiones regulares a aut√≥matas.

#### Diferencias entre AFND y $\epsilon$-AFND

La diferencia est√° en la relaci√≥n de transici√≥n:

-   En el AFND, solo hay transiciones con s√≠mbolos de $\Sigma$.\
-   En el $\epsilon$-AFND, tambi√©n puede haber transiciones etiquetadas con $\epsilon$.

### Analog√≠a constructiva: ‚ÄúEl edificio y los andamios‚Äù

Construir un AFD es como levantar un edificio colocando ladrillos definitivos desde el inicio.\
Construir un $\epsilon$-AFND es como usar andamios: las transiciones $\epsilon$ permiten unir partes del aut√≥mata de forma modular y flexible.

### Explicaci√≥n de la $\epsilon$-cerradura (epsilon-closure)

La $\epsilon$-cerradura de un estado $q$ es el conjunto de todos los estados accesibles desde $q$ usando √∫nicamente transiciones $\epsilon$.

Este concepto es crucial para eliminar $\epsilon$-transiciones y convertir un $\epsilon$-AFND en un AFND est√°ndar.


# 1.3.5 & 1.3.6: NFA con Expresiones Regulares y Forma Normal para Aut√≥matas

## Introducci√≥n

En el estudio de los lenguajes regulares, podemos describir un lenguaje de dos formas complementarias:

- **Forma Descriptiva**: Mediante **Expresiones Regulares** (dicen *qu√©* cadenas pertenecen al lenguaje)
- **Forma Reconocedora**: Mediante **Aut√≥matas Finitos** (muestran *c√≥mo* reconocer si una cadena pertenece al lenguaje)

---

## 1.3.5 Equivalencia entre NFA y Expresiones Regulares

### El Teorema de Kleene

**Teorema**: Un lenguaje es regular si y solo si puede ser descrito por una expresi√≥n regular.

> Para cualquier Expresi√≥n Regular *R*, existe un NFA *N* tal que *L(N) = L(R)*.
> 
> **Inversamente**: Para cualquier NFA *N*, existe una expresi√≥n regular *R* tal que *L(R) = L(N)*.

Esto significa que ambas representaciones son **igualmente expresivas**.

---

### Conversi√≥n: De Expresi√≥n Regular a NFA (Construcci√≥n de Thompson)

El m√©todo m√°s conocido es la **Construcci√≥n de Thompson**, que construye bloques b√°sicos de aut√≥matas y los combina usando operaciones correspondientes a los operadores de expresiones regulares.

#### Construcciones B√°sicas

**1. Cadena vac√≠a (Œµ):** Un aut√≥mata con estado inicial que transita directamente al estado final mediante Œµ.

**2. S√≠mbolo del alfabeto (a):** Un aut√≥mata que lee exactamente el s√≠mbolo 'a' y transita del inicial al final.

**3. Lenguaje vac√≠o (‚àÖ):** Un aut√≥mata donde el estado inicial no tiene forma de llegar al final.

#### Operaciones Compuestas

**1. Uni√≥n (R‚ÇÅ ‚à™ R‚ÇÇ):**
- Crear un nuevo estado inicial con dos transiciones Œµ: una hacia el aut√≥mata de *R‚ÇÅ* y otra hacia el de *R‚ÇÇ*
- Crear un nuevo estado final
- Conectar ambos aut√≥matas finales al nuevo estado final mediante Œµ
- El aut√≥mata puede "elegir" no determin√≠sticamente cu√°l camino tomar

**2. Concatenaci√≥n (R‚ÇÅR‚ÇÇ):**
- Conectar los estados de aceptaci√≥n de *NFA‚ÇÅ* con el estado inicial de *NFA‚ÇÇ* mediante transiciones Œµ
- El estado inicial es el de *NFA‚ÇÅ* y el estado final es el de *NFA‚ÇÇ*
- La transici√≥n Œµ permite "continuar" desde donde termin√≥ *R‚ÇÅ* hacia *R‚ÇÇ*

**3. Cerradura de Kleene (R*):**
- Crear un nuevo estado inicial y uno final
- A√±adir una transici√≥n Œµ directa del nuevo inicial al nuevo final (para aceptar Œµ)
- Conectar el nuevo inicial con el antiguo inicial del aut√≥mata de *R*
- Conectar el antiguo final de *R* con el nuevo final
- A√±adir una transici√≥n Œµ del antiguo final al antiguo inicial (permitiendo repetir)

**Ejemplo:** Para la expresi√≥n regular `(a|b)*c`:
1. Construir aut√≥matas para 'a' y 'b'
2. Unirlos (operaci√≥n |)
3. Aplicar Kleene (*) al resultado
4. Concatenar con el aut√≥mata para 'c'

---
Reglas
## 1.3.6 Forma Normal para Aut√≥matas

### El Problema

Para convertir un NFA en una Expresi√≥n Regular, necesitamos estandarizar el aut√≥mata, ya que un NFA t√≠pico puede tener:
- M√∫ltiples estados de aceptaci√≥n
- Ciclos complejos
- Transiciones desde y hacia el estado inicial
- Estructuras dif√≠ciles de "leer" como expresiones regulares

---

### GNFA (Aut√≥mata Finito No Determinista Generalizado)

Un **GNFA** es un aut√≥mata en forma normal que cumple con:

**1. Estado Inicial √önico:**
- Un √∫nico estado inicial sin transiciones entrantes
- Solo tiene transiciones salientes
- Garantiza que el aut√≥mata "comience limpiamente"

**2. Estado Final √önico:**
- Un √∫nico estado de aceptaci√≥n sin transiciones salientes
- Solo tiene transiciones entrantes
- Garantiza que la aceptaci√≥n sea un punto final definido

**3. Transiciones Generalizadas:**
- Las etiquetas de las transiciones son **Expresiones Regulares completas**
- Ejemplo: una transici√≥n puede estar etiquetada como `(a|b)*c`

**4. Completitud:**
- Entre cada par de estados puede haber a lo sumo una transici√≥n
- Si no existe transici√≥n f√≠sica, se considera una transici√≥n etiquetada con ‚àÖ

---

### Proceso de Normalizaci√≥n

#### Paso 1: Crear Estado Inicial √önico

Si el estado inicial tiene transiciones entrantes:
- Crear un nuevo estado inicial
- A√±adir una transici√≥n Œµ desde el nuevo inicial hacia el antiguo estado inicial

#### Paso 2: Crear Estado Final √önico

Si hay m√∫ltiples estados de aceptaci√≥n:
- Crear un nuevo estado final √∫nico
- Desde cada antiguo estado de aceptaci√≥n, a√±adir una transici√≥n Œµ hacia el nuevo estado final
- Solo el nuevo estado es de aceptaci√≥n

#### Paso 3: Convertir a Transiciones Generalizadas

Si hay m√∫ltiples transiciones entre los mismos dos estados, combinarlas en una sola transici√≥n etiquetada con la uni√≥n de todas las etiquetas.

**Ejemplo:** Si hay transiciones con 'a' y 'b' entre q‚ÇÅ y q‚ÇÇ, se combinan en una transici√≥n etiquetada con `(a|b)`.

---

### Algoritmo de Eliminaci√≥n de Estados

Una vez que el aut√≥mata est√° en Forma Normal (GNFA), se aplica el **algoritmo de Eliminaci√≥n de Estados**:

#### Objetivo

Eliminar estados intermedios uno por uno, "recableando" las transiciones para preservar el lenguaje, hasta que solo queden el estado inicial y el final.

#### Proceso de Eliminaci√≥n

Cuando eliminamos un estado *q_rip*, para cada par de estados (*q_i*, *q_j*) donde:
- Hay una transici√≥n de *q_i* a *q_rip* etiquetada con *R‚ÇÅ*
- Hay una transici√≥n de *q_rip* a *q_j* etiquetada con *R‚ÇÇ*
- Hay un ciclo en *q_rip* etiquetado con *R‚ÇÉ*
- Ya existe una transici√≥n directa de *q_i* a *q_j* etiquetada con *R‚ÇÑ*

**Nueva transici√≥n:** `R_nueva = R‚ÇÑ | R‚ÇÅR‚ÇÉ*R‚ÇÇ`

**Explicaci√≥n:**
- `R‚ÇÅ`: Lo necesario para llegar a *q_rip* desde *q_i*
- `R‚ÇÉ*`: Puede quedarse en *q_rip* cero o m√°s veces (el ciclo)
- `R‚ÇÇ`: Lo necesario para salir de *q_rip* hacia *q_j*
- `R‚ÇÑ`: La ruta directa que ya exist√≠a
- `|`: Uni√≥n (cualquiera de las dos opciones funciona)

#### Pasos Completos

1. Normalizar el NFA a GNFA
2. Mientras haya m√°s de 2 estados:
   - Elegir un estado intermedio (ni inicial ni final)
   - Calcular las nuevas expresiones regulares para cada combinaci√≥n de estados
   - Eliminar el estado intermedio y sus transiciones
3. La expresi√≥n regular en la transici√≥n entre el inicial y el final es la **expresi√≥n regular equivalente** al NFA original

---

## Ejemplo de Conversi√≥n

**NFA que acepta cadenas que terminan en 'b':**
- Estados: {q‚ÇÄ, q‚ÇÅ}
- Inicial: q‚ÇÄ
- Finales: {q‚ÇÅ}
- Transiciones: q‚ÇÄ --a--> q‚ÇÄ, q‚ÇÄ --b--> q‚ÇÄ, q‚ÇÄ --b--> q‚ÇÅ

**Proceso:**
1. Normalizar: A√±adir nuevo estado inicial y final √∫nico con transiciones Œµ
2. Generalizar transiciones: Combinar transiciones con 'a' y 'b' en q‚ÇÄ como `(a|b)`
3. Eliminar q‚ÇÄ: Calcular expresi√≥n para ir de q_start a q‚ÇÅ pasando por q‚ÇÄ
   - Entrada: Œµ, Loop: (a|b), Salida: b
   - Expresi√≥n: `Œµ(a|b)*b = (a|b)*b`
4. Eliminar q‚ÇÅ: Simplificar

**Resultado:** La expresi√≥n regular equivalente es `(a|b)*b`